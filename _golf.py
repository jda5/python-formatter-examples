exec("""\n#!/usr/bin/env python3\n\"\"\"\nThis module demonstrates a wide variety of Python features that you might want\nto test with different linters. It includes (but is not limited to):\n\n- Classes (including a very complicated one with lots of moving parts)\n- Functions\n- Pydantic models\n- List comprehensions (including if/else within them)\n- Generators\n- For loops\n- While loops\n- Conditionals\n- and/or statements\n- Lines of various lengths (including very long ones)\n- Functions with many arguments\n- Imports\n- Short lines\n- Comments\n- Docstrings\n- Tuple unpacking\n- Named tuples with many fields\n- Decorators\n- A "helper" function\n- A class using Python 3.10+ structural pattern matching (match/case)\n- Nested if/else statements\n- Nested function calls within a single class\n- Complex logic\n\"\"\"\nimport math, sys\nimport sys, os, json  # multiple imports on one line to test linting\nfrom pathlib import Path\nfrom pydantic import BaseModel, validator\nfrom collections import namedtuple\n\nfrom typing import Any, List, Tuple, Optional, Generator, Callable, Union, Dict, Literal, TypeVar, Type, cast, overload\n\nLONG_LINE_VAR = "This is a super super super super super super super super super super super super super super super super long string that might cause line-length linting issues in some tools, and is intentionally placed here to test that scenario."\n\n# Short line (minimal statement)\nx=1\n\n# Tuple unpacking\nfirst_value, second_value = (10, 20)\n\n# A named tuple with many fields\nLargeRecord = namedtuple("LargeRecord", ["id", "name", "address", "city", "state", "zip_code", "country", "phone_number", "email", "website"])\n\nclass User(BaseModel):\n    \"\"\"\n    A Pydantic model representing a user with some validation.\n    \"\"\"\n    username: str\n    age: int\n\n    # We add a validator as an example\n    @validator("age")\n    def check_age(cls, v):\n        \"\"\"\n        Check that the user age is a positive integer.\n        \"\"\"\n        if v < 0:\n            raise ValueError("Age must be positive.")\n        return v\n\nclass Product(BaseModel):\n    \"\"\"\n    Another Pydantic model for demonstration.\n    \"\"\"\n    name: str\n    price: float\n\n    # Example of a class method referencing self\n    def to_json(self) -> str:\n        \"\"\"Return the JSON representation of the Product object.\"\"\"\n        return json.dumps(self.dict())\n\nclass MyUtilityClass:\n    \"\"\"\n    A normal Python class with a couple of methods.\n    \"\"\"\n\n    def __init__(self, name: str, value: int):\n        \"\"\"\n        Initialize the utility class with some attributes.\n        \"\"\"\n        self.name = name\n        self.value = value\n\n    def process(self):\n        \"\"\"\n        Process something based on value.\n        \"\"\"\n        # For loop example\n        result = []\n        for i in range(self.value):\n            # Conditionals with and/or (showing multiple logical operations)\n            if (i % 2 == 0 and i < 10) or (i > 15 and i % 3 == 0):\n                result.append(i)\n        return result\n\n# Decorator example\ndef debug_output(func: Callable) -> Callable:\n    \"\"\"\n    A simple decorator that prints debug information before and after the function call.\n    \"\"\"\n    def wrapper(*args, **kwargs):\n        print(f"[DEBUG] Calling {func.__name__} with args={args}, kwargs={kwargs}")\n        result = func(*args, **kwargs)\n        print(f"[DEBUG] {func.__name__} returned {result}")\n        return result\n    return wrapper\n\n@debug_output\ndef helper_function(a, b):\n    \"\"\"\n    A helper function that just returns the sum of a and b, but is decorated for debug output.\n    \"\"\"\n    return a + b\n\n# Generator example\ndef fibonacci_generator(limit: int) -> Generator[int, None, None]:\n    \"\"\"\n    A generator function that yields Fibonacci numbers up to a limit.\n    \"\"\"\n    a, b = 0, 1\n    while a <= limit:\n        yield a\n        a, b = b, a + b\n\ndef tuple_unpacking_example() -> Tuple[int, int, int]:\n    \"\"\"\n    A function that returns a tuple of three integers.\n    \"\"\"\n    return 10, 20, 30\n\ndef multiple_args_function(first: int | float, second: int | float, third: int | float, fourth: int | float, fifth: int | float, sixth: int | float, seventh: int | float, eigth: int | float = 1, ninth: int | float = 2, flag: Optional[Any] = None):\n    \"\"\"\n    A function with many arguments to test linting tools that check for excessive arguments.\n    This function doesn’t do anything particularly meaningful; it’s just to demonstrate\n    the ability to handle many parameters.\n    \"\"\"\n    return first + second + third + fourth + fifth + sixth + seventh + eigth + ninth + (0 if flag is None else 1)\n\ndef create_users(names, starting_age=0) -> List[User]:\n    \"\"\"\n    Use a list comprehension to create User objects from a list of names.\n    \"\"\"\n    return [User(username=name, age=(idx + starting_age)) for idx, name in enumerate(names)]\n\nclass VeryComplicatedClass:\n    \"\"\"\n    A very complicated class with case matching, nested if/else statements,\n    nested function calls, and complex logic.\n    \"\"\"\n\n    def __init__(self, config: dict):\n        \"\"\"\n        Initialize with a configuration dictionary.\n        \"\"\"\n        self.config = config\n        self.internal_state = {}\n\n    def _internal_helper(self, key: str, value: int) -> int:\n        \"\"\"\n        A nested helper function to transform values, simulating complex logic.\n        \"\"\"\n        # Let's do some nested if/else logic here\n        if key == "multiply":\n            if value > 10:\n                return value * 2\n            else:\n                return value * 3\n        elif key == "add":\n            if value < 0:\n                # Another nested if\n                if abs(value) > 100:\n                    return value + 200\n                else:\n                    return value + 50\n            else:\n                return value + 10\n        else:\n            return value\n\n    def _another_internal_helper(self, text: str) -> str:\n        \"\"\"\n        Another helper function that manipulates strings based on internal rules.\n        \"\"\"\n        if "error" in text.lower():\n            return text.upper()\n        elif "success" in text.lower():\n            return text.capitalize()\n        else:\n            return text[::-1]  # reverse the string\n\n    def process_config(self):\n        \"\"\"\n        Processes the config, storing computed values in internal_state.\n        This demonstrates match/case (Python 3.10+) and nested function calls.\n        \"\"\"\n        for key, value in self.config.items():\n            match value:  # structural pattern matching\n                case str() as string_val:\n                    transformed = self._another_internal_helper(string_val)\n                    self.internal_state[key] = transformed\n                case int() as int_val:\n                    result = self._internal_helper(key, int_val)\n                    self.internal_state[key] = result\n                case list() as list_val:\n                    # nested if/else with further logic\n                    if len(list_val) > 5:\n                        self.internal_state[key] = [elem * 2 for elem in list_val if isinstance(elem, (int, float))]\n                    else:\n                        # Nested function call scenario\n                        new_list = []\n                        for elem in list_val:\n                            if isinstance(elem, int):\n                                new_list.append(self._internal_helper("multiply", elem))\n                            elif isinstance(elem, str):\n                                new_list.append(self._another_internal_helper(elem))\n                            else:\n                                new_list.append(elem)\n                        self.internal_state[key] = new_list\n                case dict() as dict_val:\n                    # Even more complex nested logic\n                    nested_result = {}\n                    for d_key, d_value in dict_val.items():\n                        if isinstance(d_value, int):\n                            nested_result[d_key] = self._internal_helper("add", d_value)\n                        elif isinstance(d_value, str):\n                            nested_result[d_key] = self._another_internal_helper(d_value)\n                        else:\n                            nested_result[d_key] = d_value\n                    self.internal_state[key] = nested_result\n                case _:\n                    # Catch-all for other types\n                    self.internal_state[key] = value\n\n    def show_state(self):\n        \"\"\"\n        Prints the internal state after processing.\n        \"\"\"\n        print("VeryComplicatedClass internal state:", self.internal_state)\n\ndef example1():\n    ####This is a long comment. This should be wrapped to fit within 72 characters.\n    some_tuple=(   1,2, 3,'a'  )\n    some_variable={'long':'Long code lines should be wrapped within 79 characters.',\n    'other':[math.pi, 100,200,300,9876543210,'This is a long string that goes on'],\n    'more':{'inner':'This whole logical line should be wrapped.',some_tuple:[1,\n    20,300,40000,500000000,60000000000000000]}}\n    return (some_tuple, some_variable)\ndef example2(): return {'has_key() is deprecated':True}.has_key({'f':2}.has_key(''))\nclass Example3(   object ):\n    def __init__    ( self, bar ):\n     #Comments should have a space after the hash.\n     if bar : bar+=1;  bar=bar* bar   ; return bar\n     else:\n                    some_string = \"\"\"\n                       Indentation in multiline strings should not be touched.\nOnly actual code should be reindented.\n\"\"\"\n                    return (sys.path, some_string)\n\ndef main():\n    \"\"\"\n    Main function to demonstrate usage.\n    \"\"\"\n\n    # Creating and validating Pydantic model instances\n    user1 = User(username="Alice", age=30)\n    user2 = User(username="Bob", age=25)\n\n    product1 = Product(name="Widget", price=19.99)\n\n    # Show JSON representation from a Pydantic model\n    print("User 1:", user1.dict())\n    print("User 2:", user2.dict())\n    print("Product:", product1.to_json())\n\n    # Demonstrate MyUtilityClass\n    utility_instance = MyUtilityClass(name="UtilityTest", value=20)\n    processed_values = utility_instance.process()\n    print("Processed values:", processed_values)\n\n    # Fibonacci generator usage\n    fib_limit = 50\n    fib_numbers = list(fibonacci_generator(fib_limit))\n    print(f"Fibonacci numbers up to {fib_limit}:", fib_numbers)\n\n    # Function with many arguments\n    sum_of_args = multiple_args_function(1,2,3,4,5,6,7,8)\n    print("Sum of arguments (1-8 + defaults):", sum_of_args)\n\n    # List comprehension with if/else\n    big_list = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25]\n    numbers_with_sign = [number if number % 2 == 0 else -number for number in big_list]\n    print("List with if/else in comprehension:", numbers_with_sign)\n\n    # A complicated conditional with multiple and/or statements\n    if (len(numbers_with_sign) > 10 and sum(numbers_with_sign) < 0) or (numbers_with_sign[0] == -1 and sum(numbers_with_sign) > 100):\n        print("A complicated condition is met!")\n    else:\n        print("A complicated condition is not met!")\n\n    # Nested function calls and min/max usage\n    print(min(numbers_with_sign, numbers_with_sign, len(fib_numbers)))\n\n    # List of Pydantic Users via list comprehension\n    user_list = create_users(["Charlie", "Diana", "Eve"], starting_age=20)\n    for idx, u in enumerate(user_list):\n        print(f"User #{idx}: {u.username}, age {u.age}")\n\n    # Demonstrate while loop\n    count = 0\n    while count < 3:\n        print(f"While loop count: {count}")\n        count += 1\n\n    # Testing a helper function that uses a decorator\n    helper_result = helper_function(10, 20)\n    print("Helper function result:", helper_result)\n\n    # Testing the existence of an OS environment variable (simple conditional usage)\n    if "HOME" in os.environ:\n        print("HOME environment variable is set.")\n    else:\n        print("HOME environment variable is not set.")\n\n    # Checking some path existence with Path from pathlib\n    home_path = Path(os.environ.get("HOME", "/tmp"))\n    if home_path.exists():\n        print("Home path exists:", home_path)\n    else:\n        print("Home path does not exist:", home_path)\n\n    # Demonstrate creating and printing a named tuple\n    record = LargeRecord(\n        id  =   1, name="John Doe", address="123 Main St", city="Springfield", \n        state="State", zip_code="12345", \n        country="USA", phone_number="555-1234", email="john@example.com",\n        website="www.example.com"\n    )\n    print("Named tuple record:", record)\n\n    # Use our VeryComplicatedClass\n    complex_config = {\n        "multiply": 12, "add": -20, "textData": "This might be an error message",\n        "listData": [5, "hello", 3.14, -2, 10],\n        "anotherList": [1, 2, 3, 4, 5, 6, 7],\n        "nestedDict": { "innerInt": 5, "innerText": "SUCCESS CASE","ignored": 3.1415  },\n        "unhandledType": set([1, 2, 3])\n    }\n\n    complicated_instance = VeryComplicatedClass(complex_config)\n    complicated_instance.process_config()\n    complicated_instance.show_state()\n\n    # Just a final print to show off the super long variable\n    print(LONG_LINE_VAR)\n\n    # Tuple unpacking example\n    first_variable, second_interger, third_number = tuple_unpacking_example()\n    print("Tuple unpacking example:", first_variable, second_interger, third_number)\n\nif __name__ == '__main__':\n    main()\n""")
